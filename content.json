{"meta":{"title":"冰糖的博客","subtitle":"天冷了，快穿秋裤吧","description":"没啥descriptiion","author":"冰糖","url":"http://renyajie.com"},"pages":[{"title":"categories","date":"2018-02-04T01:42:58.000Z","updated":"2018-02-04T01:42:58.224Z","comments":true,"path":"categories/index.html","permalink":"http://renyajie.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-02-04T01:42:44.000Z","updated":"2018-02-04T01:42:44.506Z","comments":true,"path":"about/index.html","permalink":"http://renyajie.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-02-04T01:40:31.000Z","updated":"2018-02-04T01:40:31.056Z","comments":true,"path":"tags/index.html","permalink":"http://renyajie.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"docker入门记录","slug":"docker入门记录","date":"2018-02-08T03:31:58.000Z","updated":"2018-02-08T06:30:49.731Z","comments":true,"path":"2018/02/08/docker入门记录/","link":"","permalink":"http://renyajie.com/2018/02/08/docker入门记录/","excerpt":"前一阵子在Docker官网上自学了Docker，本文记录那些学习成果。","text":"前一阵子在Docker官网上自学了Docker，本文记录那些学习成果。 Docker的概念和意义Docker的概念Docker是一个2013年出现的新锐，它一出现就引起了广泛的关注。因为随着互联网的不断发展，网络应用需要面对大数据量，复杂中间架构等等挑战，而解决它们所面对的最大障碍就是现存的应用和基础设施的不协调，Docker的出现让这一问题迎刃而解。它使用静态的镜像将成套的应用打包放在云端，使用容器来在服务器上运行云端的镜像而不会被服务器的基础设施所限制，也不会对服务器上其他应用产生干扰。 Docker的意义Docker最核心的部分就是容器和镜像，我认为Docker的价值都依赖于这两个创新性的概念。Docker的云端贮备着丰富的镜像文件，它们相当于一个个标准部件，大家都可以上传。当在开发和生产活动中，开发者需要什么工具就可以直接通过命令来下载镜像，然后就可以运行了，远行中的镜像被称为容器，它相当于一个操作系统的一个独立进程，摆脱了对基础设施的限制也是它重要的特性。镜像和容器的出现使得开发者能够更快更专注的进行实际的开发或维护工作，而不用每次在基础设施转移，规模扩大时大费周章。 Docker的各个组成部分镜像 image镜像(image)是一个可执行包(executable package)，它包含运行一个app所需的源代码，运行时环境，依赖库，环境变量，和构成文件。 容器 container当镜像(image)被载入内存中执行时，镜像就变成了一个容器(container)，它是镜像的运行实例。 服务 service服务(service)是生产中的容器。一个服务只运行一个镜像(image)，但是它指定了镜像运行的方式：它应该使用哪个端口，它应该运行多少个容器的克隆… …总之服务用于定制容器的该如何运行。 集群 swarm一群运行着docker的机器是一个集群(swarm)，其中有一个管理者(swarm manager)，其他都是工作者(worker)，管理者来发布命令，工作者和管理者一起来执行命令。集群里的所有机器都被称为节点(node)。 堆栈 stack一组互相关联的服务(service)被称为一个堆栈(stack)，堆栈能够协调控制各个服务之间应该如何搭配，来完成一个复杂的工作。 Docker的操作基本操作12docker login: 登录docker --version: 查看docker版本 和镜像相关的操作12345678910111213141516dokcer build -t friendlyhello .: 用当前文件夹的Dockerfile创建friendlyhello镜像(image)docker images: 查看本地的docker镜像docker image ls -a: 上同docker image rm &lt;image id&gt;: 删除特定的imagedocker image rm $(docker image ls -a -q): 删除全部的imagedocker run -p 4000:80 friendlyhello: 运行friendlyhello，并将本机的4000端口和container的80进行映射docker run -d -p 4000:80 friendlyhello: 和上面相同，但以分离模式运行docker tag image username/repository:tag: 为镜像打上标签 docker tag friendlyhello john/get-started:part2docker push username/repository:tag: 上传打过标签的镜像到目的仓库docker run username/repository:tag: 运行仓库中的镜像 docker run hello-world: 运行hello world 和容器相关的操作12345678docker container ls: 查看当前运行中的容器docker container ls -a: 查看所有容器docker container ls -q: 查看全部容器的IDdocker container stop 1fa4ab2cf395: 停止运行ID为1fa4ab2cf395的容器docker container kill 1fa4ab2cf395: 强制关闭ID为1fa4ab2cf395的容器docker container rm &lt;hash&gt;: 从本机移除指定ID的容器docker container rm $(docker container ls -a -q): 移除所有的容器 和服务相关的操作123docker service ls: 查看app中的运行中的servicedocker service ps &lt;service&gt;: 查看某个service中的task(运行中的容器) docker service ps getstartedlab_web 和集群相关的操作123456789101112131415docker swarm init: 初始化一个swarmdocker swarm leave --force: 让一个node离开swarmdocker-machine ls: 查看虚拟机docker-machine create -d hyperv --hyperv-virtual-switch &quot;myswitch&quot; myvm1: (win10,hyperv)创建myvm1虚拟机docker-machine ssh myvm1 &quot;docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;: 让虚拟机myvm1初始化swarm，并成为managerdocker-machine ssh myvm2 &quot;docker swarm join --token &lt;token&gt; &lt;ip&gt;:2377&quot;: 虚拟机myvm2加入swarmdocker-machine ssh myvm1 &quot;docker node ls&quot;: 查看swarm中的节点docker-machine start &lt;machine-name&gt;: 启动指定的虚拟机docker-machine stop &lt;machine-name&gt;: 停止指定的虚拟机docker-machine stop $(docker-machine ls -q): 停止所有的虚拟机docker-machine rm $(docker-machine ls -q): 删除所有的虚拟机docker-machine env myvm1 ~(Run the given command to configure your shell to talk to myvm1): 使用myvm1进行shell指令交互，同时可访问本地文件 和堆栈相关的操作12345docker stack ls: 列出运行中的appdocker stack deploy -c &lt;composefile&gt; &lt;appname&gt;: 运行Compse文件，并以appname进行命名 docker stack deploy -c docker-compose.yml getstartedlabdocker stack rm &lt;appname&gt;: 从stack中拆除某个app docker stack rm getstartedlab","categories":[{"name":"docker","slug":"docker","permalink":"http://renyajie.com/categories/docker/"}],"tags":[]},{"title":"github上使用同一账号对多个远程仓库推送","slug":"github上使用同一账号对多个远程仓库推送","date":"2018-02-06T01:58:35.000Z","updated":"2018-03-03T01:39:04.732Z","comments":true,"path":"2018/02/06/github上使用同一账号对多个远程仓库推送/","link":"","permalink":"http://renyajie.com/2018/02/06/github上使用同一账号对多个远程仓库推送/","excerpt":"如何使用一个Github账号将N个本地项目与N个远程仓库建立关联","text":"如何使用一个Github账号将N个本地项目与N个远程仓库建立关联 发现问题一旦一个public key在一个远程仓库中被用作推送密钥，它就不能再使用在另一个仓库上了。 问题根源通过查阅资料，了解到github上的ssh推送使用域名作为判断，往往第一个项目是可以推送的，此时第一个项目使用的域名是 github.com，注意到后面没有:username/repository name，我指的是域名。所以当为第二项目添加publickey进行推送就会出错，因为我们仍然在使用 github.com这个域名，而github不允许有重复域名推送(莫名其妙)。 解决方案解决的总体思路：使用git对不同的项目进行推送时使用不同的域名，绕过github的限制。 以项目名为goooo，用户名为renyajie为例，具体的解决方案如下： 移除项目的远程仓库1234$ git remote -vorigin git@github.com:renyajie/goooo.git(fetch)origin git@github.com:renyajie/goooo.git (push)$ git remote rm origin 添加新的远程仓库我以项目名为前缀，防止重复1234$ git remote add origin git@goooo.github.com:renyajie/goooo.git$ git remote -vorigin git@goooo.github.com:renyajie/goooo.git (fetch)origin git@goooo.github.com:renyajie/goooo.git (push) 生成项目密钥并添加在github的对应项目下注意文件用合理的名字命名，我使用项目名进行命名1234567891011121314151617181920$ ssh-keygen -t rsa -f ~/.ssh/id_rsa_goooo -C https://github.com/renyajie/gooooGenerating public/private rsa key pair.Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/User/Thor/.ssh/id_rsa_goooo.Your public key has been saved in /c/User/Thor/.ssh/id_rsa_goooo.pub.The key fingerprint is:c0:ff:ee:34:24:11:5e:6d:7c:4c:b1:a0:de:ad:be:ef https://github.com/renyajie/gooooThe key&apos;s randomart image is:+--[ RSA 2048]----+| E o..o.oo. || M o o o .+CoW || + o = o. .. || . . + || S || o . || + || . o || ..o. |+-----------------+ 编辑config文件这一步是为了指定推送项目时的域名，和之前配置的git远程仓库相对应12345$ vim ~/.ssh/config# 添加以下内容Host goooo.github.com Hostname github.com IdentityFile ~/.ssh/id_rsa_goooo 测试配置是否成功123$ ssh -T git@goooo.github.comHi renyajie/goooo! You&apos;ve successfully authenticated, but GitHubdoes not provide shell access. 2018/3/3修正：在测试配置是否成功前应该先把public key添加到guthub上","categories":[{"name":"github","slug":"github","permalink":"http://renyajie.com/categories/github/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-01-30T02:55:21.372Z","updated":"2018-02-06T01:56:24.950Z","comments":true,"path":"2018/01/30/hello-world/","link":"","permalink":"http://renyajie.com/2018/01/30/hello-world/","excerpt":"Hexo操作简介，保留了新建的Hexo项目的默认内容，方便查看博客编辑操作","text":"Hexo操作简介，保留了新建的Hexo项目的默认内容，方便查看博客编辑操作Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"测试","slug":"测试","permalink":"http://renyajie.com/categories/测试/"}],"tags":[]}]}